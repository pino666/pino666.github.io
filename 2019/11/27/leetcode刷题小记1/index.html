<!DOCTYPE html>
<html>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="本文参考于题目出自leetcode官方，有些答案参考于网络，仅供学习使用～  1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。  你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素 🌰：给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + n">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题小记(简单版)">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;27&#x2F;leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01&#x2F;index.html">
<meta property="og:site_name" content="pino">
<meta property="og:description" content="本文参考于题目出自leetcode官方，有些答案参考于网络，仅供学习使用～  1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。  你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素 🌰：给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + n">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-01-05T10:22:48.665Z">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>leetcode刷题小记(简单版)</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/pino666" target="_blank" rel="noopener">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2019/03/15/Git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/" target="_blank" rel="noopener"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&text=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&title=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&is_video=false&description=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=leetcode刷题小记(简单版)&body=Check out this article: http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&title=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&title=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&title=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&title=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&name=leetcode刷题小记(简单版)&description=" target="_blank" rel="noopener"><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-两数之和"><span class="toc-number">1.</span> <span class="toc-text">1. 两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-两数相加（中等）"><span class="toc-number">2.</span> <span class="toc-text">2. 两数相加（中等）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-无重复字符的最长子串（中等）"><span class="toc-number">3.</span> <span class="toc-text">3. 无重复字符的最长子串（中等）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-整数反转"><span class="toc-number">4.</span> <span class="toc-text">4. 整数反转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-请你来实现一个-atoi-函数，使其能将字符串转换成整数。"><span class="toc-number">5.</span> <span class="toc-text">5.请你来实现一个 atoi 函数，使其能将字符串转换成整数。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-判断一个整数是否是回文数。"><span class="toc-number">6.</span> <span class="toc-text">6. 判断一个整数是否是回文数。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-罗马数字转整数"><span class="toc-number">7.</span> <span class="toc-text">7. 罗马数字转整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-最长公共前缀"><span class="toc-number">8.</span> <span class="toc-text">8. 最长公共前缀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-有效的括号"><span class="toc-number">9.</span> <span class="toc-text">9. 有效的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-合并两个有序链表"><span class="toc-number">10.</span> <span class="toc-text">10. 合并两个有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-删除排序数组中的重复项"><span class="toc-number">11.</span> <span class="toc-text">11. 删除排序数组中的重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-移除元素"><span class="toc-number">12.</span> <span class="toc-text">12.移除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-实现-strStr-函数"><span class="toc-number">13.</span> <span class="toc-text">13. 实现 strStr() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-搜索插入位置"><span class="toc-number">14.</span> <span class="toc-text">14. 搜索插入位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-最大子序和"><span class="toc-number">15.</span> <span class="toc-text">15. 最大子序和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-最后一个单词的长度"><span class="toc-number">16.</span> <span class="toc-text">16. 最后一个单词的长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-加一"><span class="toc-number">17.</span> <span class="toc-text">17. 加一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-实现-int-sqrt-int-x-函数。"><span class="toc-number">18.</span> <span class="toc-text">18. 实现 int sqrt(int x) 函数。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-爬楼梯"><span class="toc-number">19.</span> <span class="toc-text">19.爬楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-删除排序链表中的重复元素"><span class="toc-number">20.</span> <span class="toc-text">20. 删除排序链表中的重复元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-判断相同的树"><span class="toc-number">21.</span> <span class="toc-text">21. 判断相同的树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-判断对称二叉树"><span class="toc-number">22.</span> <span class="toc-text">22.  判断对称二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-二叉树的最大深度"><span class="toc-number">23.</span> <span class="toc-text">23.二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-二叉树的层次遍历-II"><span class="toc-number">24.</span> <span class="toc-text">24. 二叉树的层次遍历 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-平衡二叉树"><span class="toc-number">25.</span> <span class="toc-text">25. 平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-二叉树的最小深度"><span class="toc-number">26.</span> <span class="toc-text">26. 二叉树的最小深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-求路径总和"><span class="toc-number">27.</span> <span class="toc-text">27. 求路径总和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-杨辉三角"><span class="toc-number">28.</span> <span class="toc-text">28. 杨辉三角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-杨辉三角-II"><span class="toc-number">29.</span> <span class="toc-text">29. 杨辉三角 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-买卖股票的最佳时机"><span class="toc-number">30.</span> <span class="toc-text">30. 买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-买卖股票的最佳时机-II"><span class="toc-number">31.</span> <span class="toc-text">31.买卖股票的最佳时机 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-验证回文串"><span class="toc-number">32.</span> <span class="toc-text">32. 验证回文串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-只出现一次的数字"><span class="toc-number">33.</span> <span class="toc-text">33. 只出现一次的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-环形链表"><span class="toc-number">34.</span> <span class="toc-text">34. 环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-最小栈"><span class="toc-number">35.</span> <span class="toc-text">35. 最小栈</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        leetcode刷题小记(简单版)
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">pino</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-11-27T10:10:26.000Z" itemprop="datePublished">2019-11-27</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote><p>本文参考于题目出自leetcode官方，有些答案参考于网络，仅供学习使用～</p>
</blockquote>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p>
<p><table><tr><td bgcolor=#D1EEEE> 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素<br> 🌰：给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]<br></td></tr></table><br>解法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    for(let i=0;i&lt; nums.length; i++)&#123;</span><br><span class="line">        for(let j = i+1; j&lt; nums.length ;j++)&#123;</span><br><span class="line">            if(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                return [i,j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>解法二:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    for(let i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">        let j = nums.indexOf(target - nums[i]);</span><br><span class="line">        if(j != i &amp;&amp; j != -1)&#123;</span><br><span class="line">            return [i , j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-两数相加（中等）"><a href="#2-两数相加（中等）" class="headerlink" title="2. 两数相加（中等）"></a>2. 两数相加（中等）</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p><table><tr><td bgcolor=#D1EEEE> 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br>🌰：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; l1</span><br><span class="line"> * @param &#123;ListNode&#125; l2</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line">var addTwoNumbers = function(l1, l2) &#123;</span><br><span class="line">    let result = new ListNode();</span><br><span class="line">    let list = result</span><br><span class="line">    let param = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while (l1 != null || l2 != null)&#123;</span><br><span class="line"></span><br><span class="line">        let l1True = l1 != null;</span><br><span class="line">        let l2True = l2 != null;</span><br><span class="line"></span><br><span class="line">        let one = l1True ? l1.val : 0;</span><br><span class="line">        let two = l2True ? l2.val : 0;</span><br><span class="line"></span><br><span class="line">        let num = (one + two + param) % 10;</span><br><span class="line">        param = Math.floor((one + two + param) / 10);</span><br><span class="line"></span><br><span class="line">        list.next = new ListNode(num);</span><br><span class="line">        list = list.next</span><br><span class="line"></span><br><span class="line">        if(l1True) l1 = l1.next</span><br><span class="line">        if(l2True) l2 = l2.next</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     if(param) &#123;</span><br><span class="line">        list.next = new ListNode(param)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    return result.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-无重复字符的最长子串（中等）"><a href="#3-无重复字符的最长子串（中等）" class="headerlink" title="3. 无重复字符的最长子串（中等）"></a>3. 无重复字符的最长子串（中等）</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">    let j = 0 ;</span><br><span class="line">    let len = 0;</span><br><span class="line">    let str = &apos;&apos;;</span><br><span class="line">    for(let i of s )&#123;</span><br><span class="line">        if(str.indexOf(i) != -1)&#123;</span><br><span class="line">            str = str + i</span><br><span class="line">            j = str.indexOf(i) + 1</span><br><span class="line">            str = str.slice(j)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">           str = str + i;  </span><br><span class="line">           len = len &gt; str.length ? len : str.length;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-整数反转"><a href="#4-整数反转" class="headerlink" title="4. 整数反转"></a>4. 整数反转</h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><table><tr><td bgcolor=#D1EEEE> 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2的31次方,  2的31次方 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。<br>🌰：输入: -123<br>输出: -321<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var reverse = function(x) &#123;</span><br><span class="line">    let result = &apos;&apos;;</span><br><span class="line">    if(Math.floor(x/10 ) == 0) return x;</span><br><span class="line">    let y = x &lt; 0 ? -x : x;</span><br><span class="line">    while(y) &#123;</span><br><span class="line">        result += y % 10;</span><br><span class="line">        y = Math.floor(y / 10);</span><br><span class="line">    &#125;</span><br><span class="line">    result = Number(result)</span><br><span class="line">    if(result &gt;= Math.pow(2, 31) - 1 || result &lt;= -Math.pow(2, 31)) return 0;</span><br><span class="line">    result = x &lt; 0 ? -result : result;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-请你来实现一个-atoi-函数，使其能将字符串转换成整数。"><a href="#5-请你来实现一个-atoi-函数，使其能将字符串转换成整数。" class="headerlink" title="5.请你来实现一个 atoi 函数，使其能将字符串转换成整数。"></a>5.请你来实现一个 atoi 函数，使其能将字符串转换成整数。</h2><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。<br>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p><table><tr><td bgcolor=#D1EEEE> 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2的31次方,  2的31次方 − 1]。如果数值超过这个范围，请返回  INT_MAX (2的31次方 − 1) 或 INT_MIN (−2的31次方) 。<br>🌰：输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; str</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var myAtoi = function(str) &#123;</span><br><span class="line">    let s = str.trim();</span><br><span class="line">    let result = &apos;&apos;;</span><br><span class="line">    let positiveNum= &apos;&apos;;</span><br><span class="line">    </span><br><span class="line">   if(!Number(s.slice(0,1)) &amp;&amp; s.slice(0,1) !== &apos;0&apos;) &#123;</span><br><span class="line">       if(s.slice(0,1) == &apos;-&apos; || s.slice(0,1) == &apos;+&apos;) &#123;</span><br><span class="line">            if(!Number(s.slice(1,2)) &amp;&amp; s.slice(1,2) !== &apos;0&apos;) return 0;</span><br><span class="line">            positiveNum = s.slice(0,1)</span><br><span class="line">            s = s.slice(1)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          return 0;  </span><br><span class="line">        &#125;   </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    for(let i of s)&#123;</span><br><span class="line">        if((!Number(i) &amp;&amp; i !== &apos;0&apos;) || i === &apos;.&apos;)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;;</span><br><span class="line">        result += i;   </span><br><span class="line">    &#125;</span><br><span class="line">    result = Number(positiveNum +  result)</span><br><span class="line">    if(result &gt;= Math.pow(2,31)-1) return Math.pow(2,31)-1;</span><br><span class="line">    if(result &lt;= -Math.pow(2,31)) return -Math.pow(2,31);</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-判断一个整数是否是回文数。"><a href="#6-判断一个整数是否是回文数。" class="headerlink" title="6. 判断一个整数是否是回文数。"></a>6. 判断一个整数是否是回文数。</h2><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。<br>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> * 通过判断整数的两半是否相等，也可直接判断整数反转后是否相等</span><br><span class="line"> */</span><br><span class="line">var isPalindrome = function(x) &#123;</span><br><span class="line">    if(x &lt; 0 ) return false;</span><br><span class="line">    if( x &gt;= 0 &amp;&amp; x &lt; 10) return true;</span><br><span class="line">    let n = 1;</span><br><span class="line">    let res = 0;</span><br><span class="line">    // 计算此数字是几位数</span><br><span class="line">    while(Math.floor(x / (Math.pow(10,n))))&#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 算出前半部分数字</span><br><span class="line">    let q = n % 2 ? Math.floor(x/Math.pow(10, (n-1)/2 + 1)) : Math.floor(x/Math.pow(10,n/2));</span><br><span class="line">    // 后半部分数字</span><br><span class="line">    let p = n % 2 ? x % Math.pow(10,(n-1)/2) : x % Math.pow(10,n/2);</span><br><span class="line">    // 将前半部分转化为后半部分</span><br><span class="line">    while(q)&#123;</span><br><span class="line">        res = res *10 + q % 10;</span><br><span class="line">        q = Math.floor(q / 10);</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断是否相等</span><br><span class="line">    if(res === p) return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-罗马数字转整数"><a href="#7-罗马数字转整数" class="headerlink" title="7. 罗马数字转整数"></a>7. 罗马数字转整数</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.<br>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var romanToInt = function(s) &#123;</span><br><span class="line">    let sum = 0;</span><br><span class="line">    let rules = &#123;</span><br><span class="line">        &apos;I&apos; : 1,</span><br><span class="line">        &apos;V&apos; : 5,</span><br><span class="line">        &apos;X&apos; : 10,</span><br><span class="line">        &apos;L&apos; : 50,</span><br><span class="line">        &apos;C&apos; : 100,</span><br><span class="line">        &apos;D&apos; : 500,</span><br><span class="line">        &apos;M&apos;: 1000,</span><br><span class="line">        &apos;IV&apos;:4,</span><br><span class="line">        &apos;IX&apos;:9,</span><br><span class="line">        &apos;XL&apos;:40,</span><br><span class="line">        &apos;XC&apos;:90,</span><br><span class="line">        &apos;CD&apos;:400,</span><br><span class="line">        &apos;CM&apos;:900,</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i = 0 ; i&lt; s.length;i++)&#123;</span><br><span class="line">        if(rules[s.slice(i,i+2)])&#123;</span><br><span class="line">            sum += rules[s.slice(i,i+2)]</span><br><span class="line">            i++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            sum += rules[s.slice(i,i+1)]</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="8-最长公共前缀"><a href="#8-最长公共前缀" class="headerlink" title="8. 最长公共前缀"></a>8. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：输入: [“flower”,”flow”,”flight”]<br>输出: “fl”。<br>所有输入只包含小写字母 a-z 。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string[]&#125; strs</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">var longestCommonPrefix = function(strs) &#123;</span><br><span class="line">    if(strs.length === 1) return strs[0];</span><br><span class="line">    if(strs.length === 0) return &quot;&quot;;</span><br><span class="line">    let result = strs[0];</span><br><span class="line">    for(let i = 1 ;i &lt; strs.length;i++)&#123;</span><br><span class="line">        let j= 0;</span><br><span class="line">        for(;j&lt;strs[0].length &amp;&amp; j&lt; strs[i].length;j++)&#123;</span><br><span class="line">            if(strs[0][j] != strs[i][j])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = result.slice(0, j);</span><br><span class="line">    &#125;</span><br><span class="line">    return  result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="9-有效的括号"><a href="#9-有效的括号" class="headerlink" title="9. 有效的括号"></a>9. 有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：输入: “()”<br>输出: true<br>输入: “()”<br>输出: true<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isValid = function(s) &#123;</span><br><span class="line">    if(s === &apos;&apos;) return true;</span><br><span class="line">    let arr = [];</span><br><span class="line">    const mapp = &#123; &apos;(&apos; :&apos;)&apos;, &apos;[&apos;:&apos;]&apos;, &apos;&#123;&apos;:&apos;&#125;&apos;&#125;;</span><br><span class="line">    for(let i of s)&#123;</span><br><span class="line">        if(mapp.hasOwnProperty(i))&#123;</span><br><span class="line">            arr.push(i)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let left = arr.pop()</span><br><span class="line">            if(mapp[left] !== i) &#123;</span><br><span class="line">                return false </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(arr.length) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="10-合并两个有序链表"><a href="#10-合并两个有序链表" class="headerlink" title="10. 合并两个有序链表"></a>10. 合并两个有序链表</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的.</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; l1</span><br><span class="line"> * @param &#123;ListNode&#125; l2</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line">var mergeTwoLists = function(l1, l2) &#123;</span><br><span class="line">  if(l1 === null) return l2;</span><br><span class="line">  if(l2 === null) return l1;</span><br><span class="line"></span><br><span class="line">  if(l1.val &lt; l2.val)&#123;</span><br><span class="line">      l1.next = mergeTwoLists(l1.next,l2)</span><br><span class="line">      return l1</span><br><span class="line">  &#125;</span><br><span class="line">    l2.next = mergeTwoLists(l1,l2.next)</span><br><span class="line">    return l2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="11-删除排序数组中的重复项"><a href="#11-删除排序数组中的重复项" class="headerlink" title="11. 删除排序数组中的重复项"></a>11. 删除排序数组中的重复项</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>(不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。)</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素.<br>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var removeDuplicates = function(nums) &#123;</span><br><span class="line">    if(nums.length === 0) return 0;</span><br><span class="line">    for(let j=0; j&lt;nums.length;)&#123;</span><br><span class="line">        if(nums[j] === nums[j+1])&#123;</span><br><span class="line">            nums.splice(j,1);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length</span><br><span class="line">&#125;;</span><br><span class="line">||</span><br><span class="line">var removeDuplicates = function(nums) &#123;</span><br><span class="line">    if(nums.length === 0) return 0;</span><br><span class="line">    let length = 1;</span><br><span class="line">    for(let j=1; j&lt;nums.length;j++)&#123;</span><br><span class="line">        if(nums[j] !== nums[j-1])&#123;</span><br><span class="line">            nums[length++] = nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="12-移除元素"><a href="#12-移除元素" class="headerlink" title="12.移除元素"></a>12.移除元素</h2><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素<br>🌰：给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; val</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var removeElement = function(nums, val) &#123;</span><br><span class="line">    let i = 0;</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    while(i &lt; len)&#123;</span><br><span class="line">        if(nums[i] == val)&#123;</span><br><span class="line">            nums[i] = nums[len-1]</span><br><span class="line">            len--;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return len</span><br><span class="line">&#125;;</span><br><span class="line">||</span><br><span class="line">var removeElement = function(nums, val) &#123;</span><br><span class="line">    for(let i = 0;i &lt; nums.length;)&#123;</span><br><span class="line">        if(nums[i] == val)&#123;</span><br><span class="line">            nums.splice(i,1)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="13-实现-strStr-函数"><a href="#13-实现-strStr-函数" class="headerlink" title="13. 实现 strStr() 函数"></a>13. 实现 strStr() 函数</h2><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：输入: haystack = “hello”, needle = “ll”<br>输出: 2<br>🌰：输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1<br>当 needle 是空字符串时我们应当返回 0 。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; haystack</span><br><span class="line"> * @param &#123;string&#125; needle</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var strStr = function(haystack, needle) &#123;</span><br><span class="line">    if(needle === &apos;&apos;) return 0;</span><br><span class="line">    return haystack.indexOf(needle)</span><br><span class="line">&#125;;</span><br><span class="line">||</span><br><span class="line">var strStr = function(haystack, needle) &#123;</span><br><span class="line">    if(needle === &apos;&apos;) return 0;</span><br><span class="line">    for(let i=0;i&lt;haystack.length;i++)&#123;</span><br><span class="line">        if(haystack[i] === needle[0])&#123;</span><br><span class="line">            if(haystack.substr(i,needle.length) === needle) return i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="14-搜索插入位置"><a href="#14-搜索插入位置" class="headerlink" title="14. 搜索插入位置"></a>14. 搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：输入: [1,3,5,6], 5<br>输出: 2<br>🌰：输入: [1,3,5,6], 0<br>输出: 0<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var searchInsert = function(nums, target) &#123;</span><br><span class="line">     let ret = 0;</span><br><span class="line">    if(nums[0] &gt; target) return 0;</span><br><span class="line">    for(let i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">        if(nums[i] &gt;= target) return i</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length;</span><br><span class="line">&#125;;</span><br><span class="line">||(二分法)</span><br><span class="line">var searchInsert = function(nums, target) &#123;</span><br><span class="line">    let left = 0;</span><br><span class="line">    let right = nums.length - 1;</span><br><span class="line">    if(nums[0] &gt; target) return 0;</span><br><span class="line">    if(nums[nums.length-1] &lt; target) return nums.length;</span><br><span class="line">    while(left &lt;= right)&#123;</span><br><span class="line">        let mid = Math.floor(left + (right - left) / 2);</span><br><span class="line">        if(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        &#125;else if(nums[mid] === target)&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="15-最大子序和"><a href="#15-最大子序和" class="headerlink" title="15. 最大子序和"></a>15. 最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maxSubArray = function(nums) &#123;</span><br><span class="line">    if(nums.length === 0 )return 0;</span><br><span class="line">    let sum = 0;</span><br><span class="line">    let ret = nums[0];</span><br><span class="line">    for(let i = 0;i&lt;nums.length;i++)&#123;</span><br><span class="line">        if(sum &gt; 0)&#123;</span><br><span class="line">            sum = sum + nums[i];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            sum=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ret = Math.max(ret,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="16-最后一个单词的长度"><a href="#16-最后一个单词的长度" class="headerlink" title="16. 最后一个单词的长度"></a>16. 最后一个单词的长度</h2><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。如果不存在最后一个单词，请返回 0 。<br>说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：输入: “Hello World”<br>输出: 5<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var lengthOfLastWord = function(s) &#123;</span><br><span class="line">    if(s === &apos;&apos;)return 0;</span><br><span class="line">    let num = 0;</span><br><span class="line">    let rst = 0;</span><br><span class="line">    for(const str of s)&#123;</span><br><span class="line">        if(str === &apos; &apos;)&#123;</span><br><span class="line">            rst = num === 0 ? rst : num </span><br><span class="line">            num = 0</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            num +=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    if(!num)&#123;</span><br><span class="line">        return rst</span><br><span class="line">    &#125; </span><br><span class="line">    return num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="17-加一"><a href="#17-加一" class="headerlink" title="17. 加一"></a>17. 加一</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123<br>🌰：输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; digits</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var plusOne = function(digits) &#123;</span><br><span class="line">    let rst = 0;</span><br><span class="line">    for(let i = digits.length -1 ; i &gt;= 0; i--)&#123;</span><br><span class="line">        digits[i] += 1</span><br><span class="line">        if(digits[i] % 10 !== 0)&#123;</span><br><span class="line">            return digits</span><br><span class="line">        &#125;</span><br><span class="line">        digits[i] = digits[i] % 10</span><br><span class="line">        if(i === 0)&#123;</span><br><span class="line">            return [1, ...digits]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="18-实现-int-sqrt-int-x-函数。"><a href="#18-实现-int-sqrt-int-x-函数。" class="headerlink" title="18. 实现 int sqrt(int x) 函数。"></a>18. 实现 int sqrt(int x) 函数。</h2><p>计算并返回 x 的平方根，其中 x 是非负整数。<br>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：输入: 4<br>输出: 2<br>🌰：输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var mySqrt = function(x) &#123;</span><br><span class="line">    return Math.floor(Math.sqrt(x))</span><br><span class="line">&#125;;</span><br><span class="line">||(粗暴法，用时与内存都极不理想)</span><br><span class="line">var mySqrt = function(x) &#123;</span><br><span class="line">    for(let i = 0; i &lt;= x; i++)&#123;</span><br><span class="line">        if(i * i &lt;= x &amp;&amp; (i+1) * (i+1) &gt; x)&#123;</span><br><span class="line">            return i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="19-爬楼梯"><a href="#19-爬楼梯" class="headerlink" title="19.爬楼梯"></a>19.爬楼梯</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶<br>🌰：输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</li>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶<br></td></tr></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">斐波那契数列（可用公式直接求出）</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var climbStairs = function(n) &#123;</span><br><span class="line">    let arr = [0,1,2]</span><br><span class="line">    for(let i=3;i&lt;=n;i++)&#123;</span><br><span class="line">        arr[i] = arr[i-1] + arr[i-2]</span><br><span class="line">    &#125;</span><br><span class="line">    return arr[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="20-删除排序链表中的重复元素"><a href="#20-删除排序链表中的重复元素" class="headerlink" title="20. 删除排序链表中的重复元素"></a>20. 删除排序链表中的重复元素</h2>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。<br><table><tr><td bgcolor=#D1EEEE>   🌰：输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>🌰：输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3<br></td></tr></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line">var deleteDuplicates = function(head) &#123;</span><br><span class="line">    let result = head</span><br><span class="line">    while(result &amp;&amp; result.next)&#123;</span><br><span class="line">        if(result.val === result.next.val)&#123;</span><br><span class="line">            result.next = result.next.next</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">             result = result.next  </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    return head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="21-判断相同的树"><a href="#21-判断相同的树" class="headerlink" title="21. 判断相同的树"></a>21. 判断相同的树</h2>给定两个二叉树，编写一个函数来检验它们是否相同。<br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<br><table><tr><td bgcolor=#D1EEEE>   🌰：输入:       <pre><code>   1         1
  / \       / \
 2   3     2   3
[1,2,3],   [1,2,3]
</code></pre></li>
</ol>
<p>输出: true<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; p</span><br><span class="line"> * @param &#123;TreeNode&#125; q</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isSameTree = function(p, q) &#123;</span><br><span class="line">    if(!p &amp;&amp; !q)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else if(!p || !q )&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;else if(p.val !== q.val)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="22-判断对称二叉树"><a href="#22-判断对称二叉树" class="headerlink" title="22.  判断对称二叉树"></a>22.  判断对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line">  3   3</span><br></pre></td></tr></table></figure><br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isSymmetric = function(root) &#123;</span><br><span class="line">    if(!root) return true;</span><br><span class="line">    return checkTree(root.left,root.right)</span><br><span class="line">&#125;;</span><br><span class="line">const checkTree = function(left,right) &#123;</span><br><span class="line">    if(!left &amp;&amp; !right) return true;</span><br><span class="line">    if(!left || !right) return false;</span><br><span class="line">    if(left.val === right.val)&#123;</span><br><span class="line">        return checkTree(left.left,right.right) &amp;&amp; checkTree(left.right,right.left)</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="23-二叉树的最大深度"><a href="#23-二叉树的最大深度" class="headerlink" title="23.二叉树的最大深度"></a>23.二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：给定二叉树 [3,9,20,null,null,15,7]，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 3</span><br><span class="line">/ \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line">15   7</span><br></pre></td></tr></table></figure><br>返回它的最大深度 3 。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maxDepth = function(root) &#123;</span><br><span class="line">    if(!root) return 0;</span><br><span class="line">    let num = Math.max( maxDepth(root.left), maxDepth(root.right) ) + 1;</span><br><span class="line">    return num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="24-二叉树的层次遍历-II"><a href="#24-二叉树的层次遍历-II" class="headerlink" title="24. 二叉树的层次遍历 II"></a>24. 二叉树的层次遍历 II</h2><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p><table><tr><td bgcolor=#D1EEEE>   🌰：例如：给定二叉树 [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 3</span><br><span class="line">/ \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line">15   7</span><br></pre></td></tr></table></figure><br>返回其自底向上的层次遍历为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var levelOrderBottom = function(root) &#123;</span><br><span class="line">    if(!root) return [];</span><br><span class="line">    let arr = [];</span><br><span class="line">    const checkTree = function(root, index)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        arr[index] = arr[index] || [];</span><br><span class="line">        arr[index].push(root.val)</span><br><span class="line">        checkTree(root.left, index+1);</span><br><span class="line">        checkTree(root.right, index+1);</span><br><span class="line">    &#125;</span><br><span class="line">    checkTree(root, 0);</span><br><span class="line">    return arr.reverse();</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="25-平衡二叉树"><a href="#25-平衡二叉树" class="headerlink" title="25. 平衡二叉树"></a>25. 平衡二叉树</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p><table><tr><td bgcolor=#D1EEEE> 本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。<br>🌰：给定二叉树 [3,9,20,null,null,15,7]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><br>返回 true 。<br>给定二叉树 [1,2,2,3,3,null,null,4,4]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><br>返回 false 。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">const balanceTree = (node) =&gt; &#123;</span><br><span class="line">    if (!node) return 0</span><br><span class="line">    return Math.max(balanceTree(node.left), balanceTree(node.right)) + 1;</span><br><span class="line">&#125;</span><br><span class="line">var isBalanced = function(root) &#123;</span><br><span class="line">    if(!root) return true;</span><br><span class="line">    if(Math.abs(balanceTree(root.left) - balanceTree(root.right)) &gt; 1) return false;</span><br><span class="line">    if(isBalanced(root.left) &amp;&amp; isBalanced(root.right)) return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="26-二叉树的最小深度"><a href="#26-二叉树的最小深度" class="headerlink" title="26. 二叉树的最小深度"></a>26. 二叉树的最小深度</h2><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><table><tr><td bgcolor=#D1EEEE> 说明: 叶子节点是指没有子节点的节点。<br>🌰：给定二叉树 [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><br>返回它的最小深度  2.<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var minDepth = function(root) &#123;</span><br><span class="line">    if(!root) return 0;</span><br><span class="line">    if(!root.left || !root.right) return Math.max(minDepth(root.left),minDepth(root.right))+1;</span><br><span class="line">    return Math.min(minDepth(root.left),minDepth(root.right))+1;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="27-求路径总和"><a href="#27-求路径总和" class="headerlink" title="27. 求路径总和"></a>27. 求路径总和</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br>说明: 叶子节点是指没有子节点的节点。</p>
<p><table><tr><td bgcolor=#D1EEEE> 说明: 叶子节点是指没有子节点的节点。<br>🌰：给定如下二叉树，以及目标和 sum = 22，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure><br>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @param &#123;number&#125; sum</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var hasPathSum = function(root, sum) &#123;</span><br><span class="line">    if(!root) return false;</span><br><span class="line">    if(!root.left &amp;&amp; !root.right) return root.val === sum;</span><br><span class="line">    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="28-杨辉三角"><a href="#28-杨辉三角" class="headerlink" title="28. 杨辉三角"></a>28. 杨辉三角</h2><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p><table><tr><td bgcolor=#D1EEEE>🌰：输入: 5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; numRows</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var generate = function(numRows) &#123;</span><br><span class="line">    let arr = [];</span><br><span class="line">    for(let i=0; i&lt;= rowIndex; i++)&#123;</span><br><span class="line">        let res = [];</span><br><span class="line">        for(let j=0;j&lt;=i;j++)&#123;</span><br><span class="line">            if(j=== 0 || j===i)&#123;</span><br><span class="line">                res.push(1);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push(arr[i-1][j-1] + arr[i-1][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(res);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="29-杨辉三角-II"><a href="#29-杨辉三角-II" class="headerlink" title="29. 杨辉三角 II"></a>29. 杨辉三角 II</h2><p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p>
<p><table><tr><td bgcolor=#D1EEEE>🌰：输入: 3<br>输出: [1,3,3,1]<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; rowIndex</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var getRow = function(rowIndex) &#123;</span><br><span class="line">    let arr = [];</span><br><span class="line">    for(let i=0; i&lt;= rowIndex; i++)&#123;</span><br><span class="line">        let res = [];</span><br><span class="line">        for(let j=0;j&lt;=i;j++)&#123;</span><br><span class="line">            if(j=== 0 || j===i)&#123;</span><br><span class="line">                res.push(1);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push(arr[i-1][j-1] + arr[i-1][j])</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(res)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr[rowIndex]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="30-买卖股票的最佳时机"><a href="#30-买卖股票的最佳时机" class="headerlink" title="30. 买卖股票的最佳时机"></a>30. 买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p><table><tr><td bgcolor=#D1EEEE>注意你不能在买入股票前卖出股票。<br>🌰：输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>🌰：输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; prices</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maxProfit = function(prices) &#123;</span><br><span class="line">    if(!prices.length) return 0;</span><br><span class="line">    let p = q = prices[0];</span><br><span class="line">    let res = 0;</span><br><span class="line">    for(let i = 1;i&lt; prices.length; i++)&#123;</span><br><span class="line">        if(prices[i] &lt; p) &#123;</span><br><span class="line">            p = q = prices[i];</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(prices[i] &gt; q)&#123;</span><br><span class="line">            q = prices[i];</span><br><span class="line">            res = q - p &gt; res ? q - p : res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="31-买卖股票的最佳时机-II"><a href="#31-买卖股票的最佳时机-II" class="headerlink" title="31.买卖股票的最佳时机 II"></a>31.买卖股票的最佳时机 II</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><table><tr><td bgcolor=#D1EEEE>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>🌰：输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br>🌰：输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; prices</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maxProfit = function(prices) &#123;</span><br><span class="line">    if(!prices.length) return 0;</span><br><span class="line">    let p = q = prices[0];</span><br><span class="line">    let res = 0;</span><br><span class="line">    for(let i = 1;i&lt; prices.length; i++)&#123;</span><br><span class="line">        if(prices[i] &lt; p) &#123;</span><br><span class="line">            p = q = prices[i];</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(prices[i] &gt; q)&#123;</span><br><span class="line">            if(i === prices.length-1)  return res+prices[i]-p;</span><br><span class="line">            if(prices[i+1] &lt; prices[i])&#123;</span><br><span class="line">                res = res + prices[i] - p;</span><br><span class="line">                q = p = prices[i];</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="32-验证回文串"><a href="#32-验证回文串" class="headerlink" title="32. 验证回文串"></a>32. 验证回文串</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><table><tr><td bgcolor=#D1EEEE>说明：本题中，我们将空字符串定义为有效的回文串。<br>🌰：输入: “A man, a plan, a canal: Panama”<br>输出: true<br>🌰：输入: “race a car”<br>输出: false。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isPalindrome = function(s) &#123;</span><br><span class="line">    let str = s.replace(/[^0-9a-zA-Z]/g,&apos;&apos;).toLowerCase();</span><br><span class="line">    let i=0;</span><br><span class="line">    let j= str.length-1;</span><br><span class="line">    let middle = Math.ceil(str.length / 2);</span><br><span class="line">    while(i &lt; middle &amp;&amp; j &gt; middle-1) &#123;</span><br><span class="line">        if(str[i] !== str[j]) return false;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="33-只出现一次的数字"><a href="#33-只出现一次的数字" class="headerlink" title="33. 只出现一次的数字"></a>33. 只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><table><tr><td bgcolor=#D1EEEE>说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br>🌰：输入: [2,2,1]<br>输出: 1<br>🌰：输入: [4,1,2,1,2]<br>输出: 4<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">解题思路：使用异或（a 异或 0 = a，a 异或 b 异或 a = b，a 异或 a = 0）</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var singleNumber = function(nums) &#123;</span><br><span class="line">    let res = 0;</span><br><span class="line">    for(num of nums) &#123;</span><br><span class="line">        res ^= num</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="34-环形链表"><a href="#34-环形链表" class="headerlink" title="34. 环形链表"></a>34. 环形链表</h2><p>给定一个链表，判断链表中是否有环。<br>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p><table><tr><td bgcolor=#D1EEEE>🌰：输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>🌰：输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var hasCycle = function(head) &#123;</span><br><span class="line">    if(!head || !head.next) return false;</span><br><span class="line">    while(head)&#123;</span><br><span class="line">        if(head.val === &apos;have&apos;) return true;</span><br><span class="line">        head.val = &apos;have&apos;;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br><span class="line">||</span><br><span class="line">var hasCycle = function(head) &#123;</span><br><span class="line">    if(!head || !head.next) return false;</span><br><span class="line">    let slow = head;</span><br><span class="line">    let fast = head.next;</span><br><span class="line">    while(slow !== fast)&#123;</span><br><span class="line">        if(!fast || !fast.next) return false;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="35-最小栈"><a href="#35-最小栈" class="headerlink" title="35. 最小栈"></a>35. 最小栈</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。<br>·push(x) – 将元素 x 推入栈中。<br>·pop() – 删除栈顶的元素。<br>·top() – 获取栈顶元素。<br>·getMin() – 检索栈中的最小元素。</p>
<p><table><tr><td bgcolor=#D1EEEE>🌰：MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.<br></td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * initialize your data structure here.</span><br><span class="line"> */</span><br><span class="line">var MinStack = function() &#123;</span><br><span class="line">    this.arr = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @return &#123;void&#125;</span><br><span class="line"> */</span><br><span class="line">MinStack.prototype.push = function(x) &#123;</span><br><span class="line">    this.arr[this.arr.length] = x;</span><br><span class="line">    return this.arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return &#123;void&#125;</span><br><span class="line"> */</span><br><span class="line">MinStack.prototype.pop = function() &#123;</span><br><span class="line">    let num = this.arr[this.arr.length-1];</span><br><span class="line">    this.arr.length = this.arr.length-1;</span><br><span class="line">    return num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">MinStack.prototype.top = function() &#123;</span><br><span class="line">    return this.arr[this.arr.length-1];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">MinStack.prototype.getMin = function() &#123;</span><br><span class="line">    let res = this.arr[0];</span><br><span class="line">    for(let num of this.arr)&#123;</span><br><span class="line">        res = res &lt; num ? res : num;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * Your MinStack object will be instantiated and called as such:</span><br><span class="line"> * var obj = new MinStack()</span><br><span class="line"> * obj.push(x)</span><br><span class="line"> * obj.pop()</span><br><span class="line"> * var param_3 = obj.top()</span><br><span class="line"> * var param_4 = obj.getMin()</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/pino666" target="_blank" rel="noopener">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-两数之和"><span class="toc-number">1.</span> <span class="toc-text">1. 两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-两数相加（中等）"><span class="toc-number">2.</span> <span class="toc-text">2. 两数相加（中等）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-无重复字符的最长子串（中等）"><span class="toc-number">3.</span> <span class="toc-text">3. 无重复字符的最长子串（中等）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-整数反转"><span class="toc-number">4.</span> <span class="toc-text">4. 整数反转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-请你来实现一个-atoi-函数，使其能将字符串转换成整数。"><span class="toc-number">5.</span> <span class="toc-text">5.请你来实现一个 atoi 函数，使其能将字符串转换成整数。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-判断一个整数是否是回文数。"><span class="toc-number">6.</span> <span class="toc-text">6. 判断一个整数是否是回文数。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-罗马数字转整数"><span class="toc-number">7.</span> <span class="toc-text">7. 罗马数字转整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-最长公共前缀"><span class="toc-number">8.</span> <span class="toc-text">8. 最长公共前缀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-有效的括号"><span class="toc-number">9.</span> <span class="toc-text">9. 有效的括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-合并两个有序链表"><span class="toc-number">10.</span> <span class="toc-text">10. 合并两个有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-删除排序数组中的重复项"><span class="toc-number">11.</span> <span class="toc-text">11. 删除排序数组中的重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-移除元素"><span class="toc-number">12.</span> <span class="toc-text">12.移除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-实现-strStr-函数"><span class="toc-number">13.</span> <span class="toc-text">13. 实现 strStr() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-搜索插入位置"><span class="toc-number">14.</span> <span class="toc-text">14. 搜索插入位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-最大子序和"><span class="toc-number">15.</span> <span class="toc-text">15. 最大子序和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-最后一个单词的长度"><span class="toc-number">16.</span> <span class="toc-text">16. 最后一个单词的长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-加一"><span class="toc-number">17.</span> <span class="toc-text">17. 加一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-实现-int-sqrt-int-x-函数。"><span class="toc-number">18.</span> <span class="toc-text">18. 实现 int sqrt(int x) 函数。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-爬楼梯"><span class="toc-number">19.</span> <span class="toc-text">19.爬楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-删除排序链表中的重复元素"><span class="toc-number">20.</span> <span class="toc-text">20. 删除排序链表中的重复元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-判断相同的树"><span class="toc-number">21.</span> <span class="toc-text">21. 判断相同的树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-判断对称二叉树"><span class="toc-number">22.</span> <span class="toc-text">22.  判断对称二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-二叉树的最大深度"><span class="toc-number">23.</span> <span class="toc-text">23.二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-二叉树的层次遍历-II"><span class="toc-number">24.</span> <span class="toc-text">24. 二叉树的层次遍历 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-平衡二叉树"><span class="toc-number">25.</span> <span class="toc-text">25. 平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-二叉树的最小深度"><span class="toc-number">26.</span> <span class="toc-text">26. 二叉树的最小深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-求路径总和"><span class="toc-number">27.</span> <span class="toc-text">27. 求路径总和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-杨辉三角"><span class="toc-number">28.</span> <span class="toc-text">28. 杨辉三角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-杨辉三角-II"><span class="toc-number">29.</span> <span class="toc-text">29. 杨辉三角 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-买卖股票的最佳时机"><span class="toc-number">30.</span> <span class="toc-text">30. 买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-买卖股票的最佳时机-II"><span class="toc-number">31.</span> <span class="toc-text">31.买卖股票的最佳时机 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-验证回文串"><span class="toc-number">32.</span> <span class="toc-text">32. 验证回文串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-只出现一次的数字"><span class="toc-number">33.</span> <span class="toc-text">33. 只出现一次的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-环形链表"><span class="toc-number">34.</span> <span class="toc-text">34. 环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-最小栈"><span class="toc-number">35.</span> <span class="toc-text">35. 最小栈</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/" target="_blank" rel="noopener"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&text=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&title=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&is_video=false&description=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=leetcode刷题小记(简单版)&body=Check out this article: http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&title=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&title=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&title=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&title=leetcode刷题小记(简单版)" target="_blank" rel="noopener"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/11/27/leetcode%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B01/&name=leetcode刷题小记(简单版)&description=" target="_blank" rel="noopener"><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick='$("#toc-footer").toggle();return false;'><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick='$("#share-footer").toggle();return false;'><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick='$("#nav-footer").toggle();return false;'><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 Zhu Xue
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/pino666" target="_blank" rel="noopener">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


